## 渲染原理

浏览器渲染：简单的说就是将 html字符串渲染成像素。

### 浏览器是如何渲染页面的？从输入网址到页面正常展示，浏览器做了什么？

当浏览器的网络线程通过网络通信收到HTML文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列中，在事件循环机制作用下，渲染主线程取出消息队列的渲染任务进行渲染。

整个渲染阶段分为8部分：html解析，样式计算，布局，分层，绘制，分块，光栅格，画。最后生成浏览器显示屏的像素点。

#### 1.HTML解析

html解析（parse Html），将字符串转换成 DOM树对象；遇到CSS代码，浏览器启动一个预解析器 转成css树对象 。

```
##### 为什么css不会阻塞html解析？

如何线程解析到link为止，此时外部的css文件还没下载好，主线程不会等待，会继续解析后续的html。因为下载和解析CSS的工作是在预解析线程中进行的，不是同一个线程。

##### html解析遇到js代码会怎么处理？

渲染进程遇到js时，必须暂停一切行为，等待下载执行完成后才能继续解析html。因为js代码有可能改动DOM树。在下载js时，预解析线程可以分摊js下载任务。
```

#### 2.样式计算

主线程会遍历DOM树对象，一次为每个节点计算出它的最终样式，被称作 “computed style"。在这一过程，相对单位会变成绝对单位（em变px)，很多预设值会变成绝对值(red变成rgb(255,0,0))。

这一步完成之后会得到一个带有样式的DOM树。

js 通过 getComputedStyle() 获取最终样式。

#### 3.布局 - layout

布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。

布局树和DOM树不一定一一对应，对于隐藏的dom节点，布局树不显示。

#### 4.分层 - layer

主线程会使用一套复杂的策略对整个布局树中进行分层。

分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。

滚动条、堆叠上下文z-index、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过`will-change`属性更大程度的影响分层结果。

```css
.box{
    /**/ 告诉浏览器需要分层
	will-change: transform
}
```

#### 5.绘制

为每一分层生成**如何绘制的指令**。渲染主线程的工作到此结束，剩下的交给其他线程完成。

#### 6.分块 - Tiling

分块会将每一层分成多个小的区域，分块工作会启动多个线程同时进行。

#### 7.光栅化 - raster

光删化，是将每个分块变成位图，优先处理靠近视口区域，此过程会用到GPU加速。

#### 8.画 - Draw

**合成线程**计算出每个位图在屏幕的位置，会生成一个个的指引信息（包含位图的位置，旋转，变形等信息），最后交于GPU进程，让GPU完成最终成像工作。





### 什么是回流（ reflow）？

回流的本质是 重新计算布局(layout)树。当布局树发生改变之后，可能影响到分层及绘制等其他渲染阶段。

未了避免布局树反复计算，浏览器会在js代码全部完成后再统一计算。所以，改动属性造成的回流reflow是异步的。这样也会造成js获取布局属性时，可能获取到的不是最新的布局信息。



### 什么是重绘（repaint）？

重绘的本质是重新根据分层信息计算绘制指令。

当改变可见样式后，就需要重新计算，触发重绘。

由于元素的布局信息属于可见样式，所以回流一定会引起重绘！！！



### 为什么 transform效率那么高？

- 1.因为transform 既不影响布局也不影响绘制，影响了渲染阶段的第八步画draw的阶段。

- 2.画的阶段在**合成线程**中，transform 变化不会影响渲染主线程。同样的渲染主线程再卡顿也不会影响到 transform 属性的变化。





