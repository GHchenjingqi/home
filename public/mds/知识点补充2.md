### 1.[<font style="color:rgb(0, 0, 0);">EventSource</font>](https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource)（SSE单向通信）
相比 WebSocket，EventSource 是**<font style="color:#DF2A3F;">单向通信</font>**，它属于 Server-Sent Events (**<font style="color:#DF2A3F;">SSE</font>**) 机制，仅支持服务器向客户端发送数据，适用于**<font style="color:#DF2A3F;">实时更新</font>**场景，如新闻推送、股票价格。

特点：

+ 单向通信：服务器向客户端
+ 自动重连：连接断开自动重连
+ 轻量级：基于http协议，比websocket更轻量

使用：

```javascript
const http = require('http');

http.createServer((req, res) => {
  const query = url.parse(req.url, true).query;
  const token = query.token;
  const userId = query.userId;

  console.log(`Received token: ${token}, userId: ${userId}`);
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
  });

  setInterval(() => {
    res.write(`data: Server time: ${new Date().toLocaleTimeString()}\n\n`);
  }, 3000);
}).listen(3000, () => {
  console.log('Server running on port 3000');
});
```

客户端接受消息：

```javascript
const eventSource = new EventSource('http://localhost:3000?token=abc&user=admin');

// 监听服务器发送的消息
eventSource.onmessage = function(event) {
  console.log('Received message:', event.data);
};

// 监听连接打开事件
eventSource.onopen = function() {
  console.log('Connection opened');
};

// 监听错误事件
eventSource.onerror = function(event) {
  console.error('Error occurred:', event);
  eventSource.close(); // 关闭连接
};
```

### 2.浏览器跨标签页面通信
#### BroadcastChannel 广播
BroadcastChannel 是现代浏览器提供的一种 跨页面通信（Cross-Page Communication）API，允许你在 同一个域名下的不同浏览器标签页、iframe 或窗口之间发送和接收消息。

使用场景：

+ 多标签页登录状态
+ 页面间数据共享
+ 实时通知广播

```javascript
//  页面1 发送
let channel = new BroadcastChannel('qux');
// 发送消息
channel.postMessage({
  type: 'notice',
  msg: 'hello world'
});

// 页面2 接收
let channel = new BroadcastChannel('qux');
// 发送消息
channel.onmessage = (e) => {
  console.log(e.data); // { type: 'notice', msg: 'hello world'}
}
```

#### onstorage 监听
监听同一域名下的localstorage变化，实现标签页面之间的消息广播。

<font style="color:#DF2A3F;">跨标签页通信、同源限制。</font>

```javascript
// 页面1 发送
localStorage.setItem('message', '今晚吃火锅！');
console.log("发送成功");
localStorage.setItem('message', '今晚吃面！')

// 页面2 接收
window.addEventListener('storage', (event) => {
  if (event.key === 'message') {
    console.log('新留言:', event.newValue);
  }
})
// 或使用onstorage
window.onstorage = function(event) {
  console.log('Storage 变更:', event);
};
```

#### ServiceWorker
Service Worker是现代 Web 应用中一个强大的后台脚本，它运行在浏览器主线程之外，作为网络代理，让你可以完全控制页面的网络请求、实现离线访问、推送通知、后台同步等功能。

它是构建 PWA（Progressive Web App，渐进式 Web 应用） 的核心技术之一。

生命周期：

+ 注册 Register
+ 安装 Install
+ 激活 Activate
+ 运行 Fetch / Message / Push 等事件

```javascript
// 页面1
navigator.serviceWorker.register('sw.js').then(() => {
  console.log("service worker 注册成功");
});
document.querySelector("button").onclick = function () {
  navigator.serviceWorker.controller.postMessage('hello');
}

// 页面2
navigator.serviceWorker.register('sw.js').then(() => {
  console.log("service worker 注册成功");
});
navigator.serviceWorker.onmessage = function ({ data }) {
  console.log(data);
}

// sw.js
self.addEventListener("message",async event=>{
  const clients = await self.clients.matchAll();
  clients.forEach(function(client){
    client.postMessage(event.data)
  });
});
```

#### Websocket
通过中间服务进行消息转发。

```javascript
// 页面1 发送
var ws = new WebSocket("ws://localhost:8080");
send.onclick = function () {
  // 如果 msg 输入框内容不是空的
  if (msg.value.trim() != '') {
    // 将 msg 输入框中的内容发送给服务器
    ws.send(msg.value.trim())
  }
}
// 页面2 接收
var ws = new WebSocket("ws://localhost:8080");
ws.onopen = function (event) {
  // 当有消息发过来时，就将消息放到显示元素上
  ws.onmessage = function (event) {
    var oP = document.createElement("p");
    oP.innerHTML = `${event.data}`;
    document.body.appendChild(oP);
  }
}
```

#### window.open
window.open + postMessage 实现标签页消息通信。

弊端，第二个页面处于打开的时候（早于发送消息的页面），有可能会通信失败！

```javascript
// 页面1 发送
let opener = null; // 保存打开窗口的引用
popBtn.onclick = function () {
  opener = window.open("index2.html");
}
btn.onclick = function () {
  let data = {
    value: content.value
  }
  // data 代表的是发送是数据，origin 用来限制访问来源，也可以用 * 代替
  opener.postMessage(data, "*");
}


// 页面2监听
window.addEventListener('message', function (e) {
  console.log(e.data);
}, false);//事件监听
```

还有其他的方法：轮询+cookie/db数据库等

